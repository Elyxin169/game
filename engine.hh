/*****************************
 *  _   _ _            __           _
 * | | (_) |          / _|         | |
 * | |_ _| | ___  ___| |_ _ __ ___ | |
 * | __| | |/ _ \/ __|  _| '_ ` _ \| |
 * | |_| | |  __/\__ \ | | | | | | | |
 *  \__|_|_|\___||___/_| |_| |_| |_|_|
 *
 *****************************/
// ascii generated by ChatGPT.
#ifndef TILESFML_HEADER_PROT
#define TILESFML_HEADER_PROT 69
#include <iostream>
#include <SFML/Graphics.hpp>
#define mainloop while (window.isOpen())
#define eventsLeft window.pollEvent(event)

#define vec3 sf::Vector3f
#define vec2 sf::Vector2f
#define vec3i sf::Vector3i
#define vec2i sf::Vector2i

#define gravConst 9.81

#define centerAlign 1
#define leftAlign 2
#define rightAlign 3

namespace tsf
{
      //    Types

      // @brief A color gradient.
      // @param fillColor The color to fill the tile with
      // @param bordColor The color of the 5px wide outline
      struct Gradient
      { // TIL C++ doesnt accept typedef here
            sf::Color fillColor;
            sf::Color bordColor;
            bool operator==(const Gradient &a) const
            { /*
                   fillColor.r == a.fillColor.r && fillColor.g == a.fillColor.g && fillColor.b == a.fillColor.b
                   bordColor.r == a.bordColor.r && bordColor.g == a.bordColor.g && bordColor.b == a.bordColor.b*/
                  return (fillColor.r == a.fillColor.r && fillColor.g == a.fillColor.g && fillColor.b == a.fillColor.b && bordColor.r == a.bordColor.r && bordColor.g == a.bordColor.g && bordColor.b == a.bordColor.b);
            }
      };

      /*
      typedef struct{
            sf::RectangleShape shell;
            Gradient gradient;
      } Tile;*/

      class Tile
      {
      public:
            sf::RectangleShape shell;
            Gradient gradient;
            void draw(sf::RenderWindow *window)
            {
                  window->draw(this->shell);
            }
            bool touches(Tile tile2)
            {
                  return this->shell.getGlobalBounds().intersects(tile2.shell.getGlobalBounds());
            }
            void updGradient(Gradient grad)
            {
                  this->gradient = grad;
                  this->shell.setFillColor(grad.fillColor);
                  this->shell.setOutlineColor(grad.bordColor);
            }
      };

      class Button
      {
      public:
            Tile tile;
            char *text;
            int fontSize;
            sf::Font font;
            int align;
            bool isClicked(sf::RenderWindow *window)
            {
                  if (sf::Mouse::isButtonPressed(sf::Mouse::Left))
                        return tile.shell.getGlobalBounds().contains(window->mapPixelToCoords(sf::Mouse::getPosition(*window)));
                  else
                        return false;
            }
            void draw(sf::RenderWindow *window)
            {
                  window->draw(this->tile.shell);
                  // check alignment here
                  sf::Text tmp;
                  tmp.setString(this->text);
                  tmp.setFont(font);
                  tmp.setCharacterSize(fontSize);
                  if (this->align == leftAlign) // probably not too good of an idea doing these every time its drawn but cmon its 2d im lazy
                        tmp.setPosition(this->tile.shell.getPosition() + sf::Vector2f(10,
                                                                                      this->tile.shell.getSize().y / 2 - fontSize / 2));
                  else if (this->align == centerAlign)
                        tmp.setPosition(this->tile.shell.getPosition() + sf::Vector2f(
                                                                             this->tile.shell.getSize().x / 2 - tmp.getLocalBounds().width / 2,
                                                                             this->tile.shell.getSize().y / 2 - fontSize / 2));
                  else if (this->align == rightAlign)
                        tmp.setPosition(this->tile.shell.getPosition() + sf::Vector2f(
                                                                             this->tile.shell.getSize().x - tmp.getLocalBounds().width - 10,
                                                                             this->tile.shell.getSize().y / 2 - fontSize / 2));
                  window->draw(tmp);
            }
      };

      class TextBox
      {
      public:
            Tile tile;
            char *text;
            int fontSize;
            sf::Font font;
            int align;
            void draw(sf::RenderWindow *window)
            {
                  window->draw(this->tile.shell);
                  sf::Text tmp;
                  tmp.setString(this->text);
                  tmp.setFont(font);
                  tmp.setCharacterSize(fontSize);
                  // tmp.setStyle(sf::Text::Bold);
                  if (this->align == leftAlign) // probably not too good of an idea doing these every time its drawn but cmon its 2d im lazy
                        tmp.setPosition(this->tile.shell.getPosition() + sf::Vector2f(10,
                                                                                      this->tile.shell.getSize().y / 2 - fontSize / 2));
                  else if (this->align == centerAlign)
                        tmp.setPosition(this->tile.shell.getPosition() + sf::Vector2f(
                                                                             this->tile.shell.getSize().x / 2 - tmp.getLocalBounds().width / 2,
                                                                             this->tile.shell.getSize().y / 2 - fontSize / 2));
                  else if (this->align == rightAlign)
                        tmp.setPosition(this->tile.shell.getPosition() + sf::Vector2f(
                                                                             this->tile.shell.getSize().x - tmp.getLocalBounds().width - 10,
                                                                             this->tile.shell.getSize().y / 2 - fontSize / 2));
                  window->draw(tmp);
            }
      };

      class CollisionTable
      {
      public:
            std::vector<Tile *> tiles;
            bool hits(Tile *obj)
            {
                  bool hit = false;
                  for (int i = 0; i < this->tiles.size(); i++)
                  {
                        if (this->tiles[i]->touches(*obj))
                        {
                              hit = true;
                              break;
                        }
                  }
                  return hit;
            }
      };
      //    Constants

      const Gradient Gray = {sf::Color(89, 89, 89), sf::Color(65, 65, 65)};
      const Gradient Grey = Gray; // the bri'ish god damn
      const Gradient Red = {sf::Color(214, 21, 21), sf::Color(140, 17, 17)};
      const Gradient Green = {sf::Color(65, 255, 65), sf::Color(24, 148, 24)};
      const Gradient Blue = {sf::Color(2, 149, 209), sf::Color(5, 87, 120)};
      const Gradient DarkBlue = {sf::Color(2, 50, 255), sf::Color(5, 30, 180)};

      // you should not use these for text. use sf::Text.
      const Gradient cleanGray = {sf::Color(89, 89, 89), sf::Color(89, 89, 89)};
      const Gradient cleanGrey = cleanGray; // the bri'ish god damn
      const Gradient cleanRed = {
          sf::Color(214, 21, 21),
          sf::Color(214, 21, 21),
      };
      const Gradient cleanGreen = {sf::Color(65, 255, 65), sf::Color(65, 255, 65)};
      const Gradient cleanBlue = {sf::Color(2, 149, 209), sf::Color(2, 149, 209)};
      const Gradient cleanDarkBlue = {sf::Color(2, 50, 255), sf::Color(2, 50, 255)};

      //    Functions

      void nothing_placeholder() {}

      Tile genTile(sf::Vector2f size, sf::Vector2f position, Gradient gradient = Gray)
      {
            Tile tmp;
            sf::RectangleShape rectTmp(size);
            rectTmp.setPosition(position);
            rectTmp.setFillColor(gradient.fillColor);
            rectTmp.setOutlineColor(gradient.bordColor);
            rectTmp.setOutlineThickness(-5);
            tmp.shell = rectTmp;
            tmp.gradient = gradient;
            return tmp;
      }
      Button genButton(Tile tile, char *text, sf::Font font, int fontSize, int align = centerAlign)
      {
            Button tmp;
            tmp.text = text;
            tmp.tile = tile;
            tmp.font = font;
            tmp.fontSize = fontSize;
            tmp.align = align;
            return tmp;
      }
      TextBox genTextBox(Tile tile, char *text, sf::Font font, int fontSize, int align = centerAlign)
      {
            TextBox tmp;
            tmp.text = text;
            tmp.tile = tile;
            tmp.font = font;
            tmp.fontSize = fontSize;
            tmp.align = align;
            return tmp;
      }
      float center(int canv, int obj)
      {
            return (canv - obj) / 2;
      }
      // rough estimate, works as long as its 60fps
      int sec2frame(int sec)
      {
            return sec * 60;
      }
}

#endif